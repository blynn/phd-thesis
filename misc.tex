\chapter{Miscellaneous Optimizations}

Optimizing a pairing-based cryptosystem can be quite involved:

\begin{enumerate}
\item
Much effort must be devoted to speeding up
integer and finite field arithmetic operations, as they are present
in large amounts at the lowest level. For best results, platform-dependent
hand-coded assembly should be used.
Fortunately a lot of research has been conducted in this area,
and many implementations exist, some of them freely available.
\item
Elliptic curve operations should also be fast. Though a newer area of research,
numerous publications on this subject exist~\cite{bss}.
\item
Speeding up the pairing has only been a high priority relatively recently,
and is one of the main focuses of some of the previous chapters.
\item
Sometimes modifications to a scheme will garner savings by
permitting larger amounts of precomputation, exploiting pairing
properties, moving exponentiations to cheaper groups, compressing points or
pairings, and so on.
\item
Needless to say, each of these classes of optimizations cannot be viewed
in isolation. An optimization that may not usually help could be beneficial
when the behaviour of the whole system is taken into account.
Similarly, one optimization could adversely affect another.
For one example, see the discussion on Montgomery representation below.
\end{enumerate}

\section{On Using Existing Libraries}

In the author's pairing implementations, to avoid the drawbacks
of assembly code (e.g. loss of portability, the need to learn platform-specific
low-level tricks, frequent rewrites due to new hardware,
fewer potential developers, increase in debugging difficulty, longer
development time),
pre-existing multiprecision arithmetic libraries
were utilized.

Obviously a library
designed for maximum efficiency when using finite fields
of cryptographically useful magnitude is most desirable.
If no suitable library is available (perhaps due to reasons unrelated
to performance such as lack of portability or licensing issues),
one can easily graft finite field routines on top of
any arbitrary-precision integer library, though doing so can cause losses.

For example, the GMP library has a highly optimized modular exponentiation
routine that uses Montgomery reduction (see below),
but expects the input not to be
in Montgomery form, and also outputs normal integers.

Hence if numbers are already internally stored in Montgomery form,
they must be converted to a normal integer first, and then converted
back to Montgomery form afterwards. Including the unwanted conversions in
GMP itself gives a total of four unnecessary conversions.

Another example is that an external library may be able to handle integers
of arbitrary length, but a particular deployment of a cryptosystem is
concerned only with integers in a certain range. Routines that know
in advance how many bytes their input integers take can be faster than
a more general routine.

\section{All or Nothing}

The nature of cryptography in a finite field requiring $n$ bytes per element
leads to the value of an integer data structure
often containing either zero, or an integer roughly $n$ bytes in length.
This is because many cryptographic operations can be viewed as a series of
arithmetic operations on $n$-byte numbers uniformly chosen at random.

One approach to exploit this is to attach a flag to every integer variable
that signifies when the variable contains the zero value. Then operations
such as addition and multiplication check this flag: if one of the input
variables is zero, the output is trivial to determine and no looping
is required, otherwise the computation should proceed on all $n$ bytes as
with high probability each of the $n$ bytes will be nonzero and thus
contribute to the result.

In some cases it may help to test for one as well.

\section{Montgomery Reduction}

For RSA or a discrete-log system in a finite field, it is recommended
only to use Montgomery reduction during an exponentiation
as the time lost from switching back and forth between representations
does not compensate for the savings gained for individual multiplications~\cite{handbook}.

Pairing-based cryptosystems on the other hand can benefit from having
all coordinates of points stored in Montgomery representation, with conversion
only during input and output (though even then, there is no reason why keys
and such could not be stored in Montgomery representation). This is because
during point additions and multiplications as well as pairing computations,
there are many finite field operations but never a need to convert the
coordinates back to its normal representation.

Division is slower using Montgomery representation, but this drawback is
of no concern if projective coordinates are used, where each division is
replaced by a few multiplications in any case.

\section{Cube Roots}

When $q = 2 \pmod 3$, for any $x \in \Fq$ we have
$(x^{-(q-2)/3})^3 = x^{1-(q-1)} = x / x^{q-1} = x$,
thus cube roots can be quickly found via exponentiaton
by $-(q-2)/3$. Observe this also means every element of $\Fq$ has
a cube root, which implies cube roots are unique.

Thus with curves of the form $Y^2 = X^3 + b$ over such fields,
a better way of finding random points is to choose $Y$ randomly and
solve for $X$, which involves taking a cube root. Additionally,
point reduction and compression can be achieved by discarding the
$x$-coordinate and only recording the $y$-coordinate. In particular,
for point compression there is no need to store an extra bit and
for point reduction no information is lost.

\section{Dedicated Squaring}

A relatively painless way to improve running times
is to implement squaring routines for every field, ring or group.

In the next section we describe squaring tricks
for $\F_{q^2}$ when $q$ is a prime satisfying $q = 2 \pmod 3$
or $q = 3 \pmod 4$.

More generally, for low degree extensions (e.g. 3, 6),
hand-coding generalized Karatsuba squaring and
multiplication algorithms \cite{wpkaratsuba}.

\section{Quadratic Field Extensions}

For primes $q=3\pmod 4$, a degree two field extension of $\Fq$
should be implemented as $\Fq[i]$ where $i$ is a square root of $-1$.

We have
\[ (a + i b)^2 = (a - b)(a + b) + i (2 a b) \]
and
\[ (a + i b)(c + i d) = (ac - bd) + i[(a + b)(c + d) - ac - bd] \]

As mentioned in the previous chapter, in $\Fq[i]$,
exponentiation by $q$ can be performed by simply negating the imaginary part:
\[ (a+ib)^q = a - ib \]
which in turn implies computing expressions such as $x z - y z^q$ only
costs four multiplications in $\Fq$, where $x,y,z \in \Fq[i]$.

For primes $q=2\pmod 3$,
the polynomial $X^2 + X + 1$ irreducible in $\Fq$, thus its roots
form an optimal normal basis of $\F_{q^2}$
allowing several shortcuts~\cite{xtr}.

Thus if $q\ne 3\pmod 4$ (so we cannot extend by a square root of $-1$ since
it already exists in $\Fq$), a good choice is to use the above basis.
In other words, we compute in $\Fq[\alpha]_{\alpha^2+\alpha+1}$
(viewing $\alpha$ as an indeterminate) and represent elements
as tuples $(a,b) \in \Fq \times \Fq$ (which means $a \alpha + b \alpha^2$).
Note $\alpha^3 = 1$ and $x\in\Fq$ may be written as $-x \alpha - x\alpha^2$.

Then
\[ (a \alpha + b \alpha^2)^2 = b(b-2a)\alpha + a(a-2b)\alpha^2 \]
and
\[ (a \alpha + b \alpha^2)(c \alpha + d \alpha^2) =
(bd-ad-bc)\alpha + (ac-ad-bc)\alpha^2 \]

We also have
\[ (a\alpha + b\alpha^2)^q = b\alpha + a\alpha^2 \]
which again implies computing expressions such as $x z - y z^q$ only
costs four multiplications in $\Fq$, where $x,y,z \in \F_{q^2}$.

\section{Last-Second Conversions}

One easy optimization is also easy to overlook as it is hidden by
notation.

Consider a type A pairing $e : E(\mathbb{F}_q) \times E(\mathbb{F}_q)
\rightarrow \mathbb{F}_{q^2}$, and suppose we have chosen to
use $\mathbb{F}_q [i]$ to represent $\mathbb{F}_{q^2}$.

During the computation of the pairing,
we evaluate $g(Q')$ where $g = aX + bY + c$ is an equation of some line and
$Q' = \phi(Q)$, where $\phi$ is defined by  $(X,Y) \rightarrow (-X, iY)$
and $Q$ is some point $(x,y)$ in $E(\mathbb{F}_q)$.

If we follow the notation blindly, we would first compute the point
$Q'$ which takes twice as much storage as $Q$ (as the field it lies over is
twice as big), and computing $g(Q')$ involves
operations on elements of $\mathbb{F}_q[i]$.

Instead, it is wiser to never explicitly compute $Q'$, and instead
performs the following:

\begin{enumerate}
\item
$Re(R) = c - a x$
\item
$Im(R) = b y$
\end{enumerate}

Now $R = g(Q')$, and we have only computed in $\mathbb{F}_q$.

Similar statements can be made for other pairing types, with greater
savings in some cases.

\section{Finding a Root of a Polynomial}

When computing parameters for curves using the CM method, we
need to find a root of a Hilbert polynomial modulo a prime.
As we only want a single root, we may use the Cantor-Zassenhaus
method and skip many steps. For example, we do not care about
the multiplicity of the factors or factors of degree higher than 1.
Thus we may do the folliowing to find a root of a
degree $n$ polynomial $f(x)$ in
$\F_q$.

\begin{enumerate}
\item
Compute $g(x) = \gcd(x^q - x, f(x))$.
\item
If $\deg g = 1$ then output the root and stop.
\item
Pick a random $r \in \Fq$. If $r$ is a root then stop.
\item
Compute $s(x) = (x-r)^{(q-1)/2} \bmod g(x)$.
\item
Compute $g'(x) = \gcd(s(x)+1, g(x))$. This is a proper factor of $g$
with probability $1 - 2^{n-1}$. So if $g'(x) \ne 1$ set $g = g'$ and
goto step 2.
\item
Goto step 3.
\end{enumerate}

\section{Preprocessing}

We previously discussed preprocessing for pairings,
but other opportunities for
calculating and storing results ahead of time often exist.

For example, in some schemes, we must exponentiate the some group element $g$
of some group $G$ by various powers. Then TODO

One trivial application of this principle
is that the random points needed for certain pairing
computations can be chosen and stored long before they are needed.
