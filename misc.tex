\chapter{Miscellaneous Optimizations}

Improving the efficiency of a pairing-based cryptosystem can be quite involved:

\begin{enumerate}
\item
Much effort must be devoted to speeding up
integer and finite field arithmetic operations, as they are present
in large amounts at the lowest level. For best results, platform-dependent
hand-coded assembly should be used.
Fortunately a lot of research has been conducted in this area,
and numerous implementations exist, many of them freely available.
\item
Elliptic curve operations should also be fast. Though a newer area of research,
numerous publications on this subject exist~\cite{bss}.
\item
Speeding up the pairing has only been a high priority relatively recently,
and is one of the main focuses of some of the previous chapters.
\item
Sometimes high-level modifications to a scheme (such as allowing one or
two bits of error, choosing a different group to contain a key, etc.)
will garner savings by
permitting one to
exploit other pairing properties,
move exponentiations or multiplications to cheaper groups,
precompute more elements,
compress or reduce points or pairings, and so on.
\item
Needless to say, each of these classes of optimizations cannot be viewed
in isolation. An optimization that may not usually help could be beneficial
when the behaviour of the whole system is taken into account.
For one example, see the discussion on Montgomery representation below.
Similarly, one optimization could adversely affect another.
\end{enumerate}

We have concentrated optimizations from all aspects of
a pairing-based cryptosystem into a couple of chapters,
rather than introduce each technique along with the algorithm that it
affects. We prefer presenting shortcuts in one go as a big bag of tricks to
sprinkling them throughout the text.
The last item of the above list relates one reason.

Secondly, an optimization buried in the middle of a section on another topic
may be overlooked or forgotten. This may be less likely when it is found in
a section dedicated to optimizations.

Also, optimizations from different areas can have much in common. For example,
sliding windows and multiexponentiation apply to every repeated-squaring-like
algorithm. Seeing all variants at once can provide a deeper understanding of
a principle, and may even inspire one to apply the same principle to a
different situation.

Lastly, the organization of these chapters reflects good software
engineering practices. When developing a pairing-based cryptography
library from scratch,
the initial goal should be to write finite field arithmetic
routines, including
quadratic extensions. The next
step is to implement elliptic curve groups.
Once the code for this has been tested satisfactorily, a simple
pairing algorithm should be built.
Only when the pairing is correctly functioning
should one at last even consider efficiency improvements.

The slowest parts of the system should be attacked first.
Educated guessing can meet with some success, but
ideally profiling should be employed to identify the
bottlenecks.

(On the other hand, interspersing descriptions of optimizations
among the whole work may be better in other circumstances, such as
when efficiency is not one of the main focuses.)

\section{On Using Existing Libraries}

In the author's pairing implementations, to avoid the drawbacks
of assembly code (e.g. loss of portability, the need to learn platform-specific
low-level tricks, frequent rewrites due to new hardware,
fewer potential developers, increase in debugging difficulty, longer
development time),
pre-existing multiprecision arithmetic libraries
were utilized.

Obviously, the ideal choice is
a library designed for maximum efficiency when using finite
fields sizes typically found in cryptography.
But if no suitable library is available (perhaps due to reasons unrelated
to performance such as lack of portability or licensing issues),
one can easily graft finite field routines on top of
any arbitrary-precision integer library, though doing so can cause losses.

For example, the GMP library has a highly optimized modular exponentiation
routine that uses Montgomery reduction (see below),
but expects the input not to be
in Montgomery form, and also outputs normal integers.

Hence if numbers are already internally stored in Montgomery form,
they must be converted to a normal integer first, and then converted
back to Montgomery form afterwards. Including the unwanted conversions in
GMP itself gives a total of four unnecessary conversions.

Another example is that an external library may be able to handle integers
of arbitrary length, but a particular deployment of a cryptosystem is
concerned only with integers in a certain range. Routines that know
in advance how many bytes their input integers take can be faster than
a more general routine.

\section{All or Nothing}

The nature of cryptography in a finite field requiring $n$ bytes per element
leads to the value of an integer data structure
often containing either zero, or an integer roughly $n$ bytes in length.
This is because many cryptographic operations can be viewed as a series of
arithmetic operations on $n$-byte numbers uniformly chosen at random.

One approach to exploit this is to attach a flag to every integer variable
that signifies when the variable contains the zero value. Then operations
such as addition and multiplication check this flag: if one of the input
variables is zero, the output is trivial to determine and no looping
is required, otherwise the computation should proceed on all $n$ bytes as
with high probability each of the $n$ bytes will be nonzero and thus
contribute to the result.

In some cases it may help to test for one as well.

Of course, one could rewrite higher level algorithms to avoid these cases
but this can be tedious and may only be negligibly better.

\section{Montgomery Reduction}

For RSA or a discrete-log system in a finite field, it is recommended
only to use Montgomery reduction during an exponentiation
as the time lost from switching back and forth between representations
does not compensate for the savings gained for individual multiplications~\cite{handbook}.

Pairing-based cryptosystems on the other hand can benefit from having
all coordinates of points stored in Montgomery representation, with conversion
only during input and output (though even then, there is no reason why keys
and such could not be stored in Montgomery representation). This is because
during point additions and multiplications as well as pairing computations,
there are many finite field operations but never a need to convert the
coordinates back to its normal representation.

Division is slower using Montgomery representation, but this drawback is
of no concern if projective coordinates are used, where each division is
replaced by a few multiplications in any case.

\section{Cube Roots}

When $q = 2 \pmod 3$, for any $x \in \Fq$ we have
$(x^{-(q-2)/3})^3 = x^{1-(q-1)} = x / x^{q-1} = x$,
thus cube roots can be quickly found via exponentiaton
by $-(q-2)/3$. Observe this also means every element of $\Fq$ has
a cube root, which implies cube roots are unique.

Thus with curves of the form $Y^2 = X^3 + b$ over such fields,
a better way of finding random points is to choose $Y$ randomly and
solve for $X$, which involves taking a cube root. Additionally,
point reduction and compression can be achieved by discarding the
$x$-coordinate and only recording the $y$-coordinate. In particular,
for point compression there is no need to store an extra bit and
for point reduction no information is lost.

\section{Random Points}

Let $E : Y^2 = X^3 + a X + b$ be an elliptic curve and suppose we
are working within a cyclic subgroup $G$ of order $r$
of the points of $E$.

To find a random point in $G$, one can randomly choose an $x$-coordinate and
attempt to solve the equation $E$ for the $y$-coordinate, which involves
a finite-field square root algorithm. If no solution exists, more
$x$-coordinates are chosen until a solution for $y$ can be found.

As soon as valid coordinates are obtained,
point multiplication by an appropriate
factor ensures the resulting point $P$ lies in $G$.

In certain curves noted above, there are advantages to choosing $y$ and
solving for $x$ instead.

In either case,
once such a point is found, future random points can be generated by
picking a random $k \in \{0,...,r-1\}$ and returning $kP$. This
can be faster in some curves, though it is an inferior method on others.

To ensure that the point is uniformly chosen from $G$, the point
$P$ must have order $r$, though in most cases (i.e. when $r$ is a large prime
or a product of large primes) this happens with high probability.

When $G$ is not cyclic, but each point has order dividing $r$,
we may of course extend this technique by finding a linearly independent
basis of $G$ and form some linear combination using them,
where the coefficients are chosen randomly.

However, in this case,
many pairing-based cryptosystems still function even if random
points are picked from a cyclic subgroup of $G$ only, and we merely need
one point of $G$ of order $r$.

\section{Dedicated Squaring}

A relatively painless way to improve running times
is to implement squaring routines for every field, ring or group.

In the next section we describe squaring tricks
for $\F_{q^2}$ when $q$ is a prime satisfying $q = 2 \pmod 3$
or $q = 3 \pmod 4$.

More generally, for low degree extensions (e.g. 3, 6),
hand-coding generalized Karatsuba squaring and
multiplication algorithms \cite{wpkaratsuba}.

\section{Quadratic Field Extensions}

For primes $q=3\pmod 4$, a degree two field extension of $\Fq$
should be implemented as $\Fq[i]$ where $i$ is a square root of $-1$.

We have
\[ (a + i b)^2 = (a - b)(a + b) + i (2 a b) \]
and
\[ (a + i b)(c + i d) = (ac - bd) + i[(a + b)(c + d) - ac - bd] \]

As mentioned in the previous chapter, in $\Fq[i]$,
exponentiation by $q$ can be performed by simply negating the imaginary part:
\[ (a+ib)^q = a - ib \]
which in turn implies computing expressions such as $x z - y z^q$ only
costs four multiplications in $\Fq$, where $x,y,z \in \Fq[i]$.

For primes $q=2\pmod 3$,
the polynomial $X^2 + X + 1$ irreducible in $\Fq$, thus its roots
form an optimal normal basis of $\F_{q^2}$
allowing several shortcuts~\cite{xtr}.

Thus if $q\ne 3\pmod 4$ (so we cannot extend by a square root of $-1$ since
it already exists in $\Fq$), a good choice is to use the above basis.
In other words, we compute in $\Fq[\alpha]_{\alpha^2+\alpha+1}$
(viewing $\alpha$ as an indeterminate) and represent elements
as tuples $(a,b) \in \Fq \times \Fq$ (which means $a \alpha + b \alpha^2$).
Note $\alpha^3 = 1$ and $x\in\Fq$ may be written as $-x \alpha - x\alpha^2$.

Then
\[ (a \alpha + b \alpha^2)^2 = b(b-2a)\alpha + a(a-2b)\alpha^2 \]
and
\[ (a \alpha + b \alpha^2)(c \alpha + d \alpha^2) =
(bd-ad-bc)\alpha + (ac-ad-bc)\alpha^2 \]

We also have
\[ (a\alpha + b\alpha^2)^q = b\alpha + a\alpha^2 \]
which again implies computing expressions such as $x z - y z^q$ only
costs four multiplications in $\Fq$, where $x,y,z \in \F_{q^2}$.

\section{Finding a Root of a Polynomial}

When computing parameters for curves using the CM method, we
need to find a root of a Hilbert polynomial modulo a prime.
As we only want a single root, we may use the Cantor-Zassenhaus
method and skip many steps. For example, we do not care about
the multiplicity of the factors or factors of degree higher than 1.
Thus we may do the folliowing to find a root of a
degree $n$ polynomial $f(x)$ in
$\F_q$.

\begin{enumerate}
\item
Compute $g(x) = \gcd(x^q - x, f(x))$.
\item
If $\deg g = 1$ then output the root and stop.
\item
Pick a random $r \in \Fq$. If $r$ is a root then stop.
\item
Compute $s(x) = (x-r)^{(q-1)/2} \bmod g(x)$.
\item
Compute $g'(x) = \gcd(s(x)+1, g(x))$. This is a proper factor of $g$
with probability $1 - 2^{n-1}$. So if $g'(x) \ne 1$ set $g = g'$ and
goto step 2.
\item
Goto step 3.
\end{enumerate}

\section{Preprocessing}

We previously discussed preprocessing for pairings,
but other opportunities for
calculating and storing results ahead of time often exist.

For example, in some schemes, we must exponentiate the some group element $g$
of some group $G$ by various powers. Then TODO

One trivial application of this principle
is that the random points needed for certain pairing
computations can be chosen and stored long before they are needed.
Another is the caching of quadratic nonresidues that are key
ingredients in a number of algorithms.

\section{Multiexponentiation}

TODO: move ecc opts here, mention low hamming field bad, low hamming
order not so bad
