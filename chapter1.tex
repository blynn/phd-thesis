\chapter{Bilinear Maps}

Much of modern cryptography depends (and was founded\cite{diffie76new})
on a cyclic group $G = \langle g \rangle$ of prime order $r$ where certain
problems are hard to solve:

\begin{description}
\item [Discrete Log Problem]
Given $g, g^x$, compute $x$.
\item [Computational Diffie-Hellman Problem]
Given $g, g^x, g^y$, compute $g^{x y}$
\item [Decisional Diffie-Hellman Problem]
Given $g, g^x, g^y, g^z$, determine if $x y = z$.
\end{description}

TODO: formal defn of hard

A vast array of cryptosystems can be built thanks to these groups. 
But what if we could somehow augment these groups and increase their
capabilities?

Bilinear maps, or pairings, are functions with special
properties that exist for some of these groups.
They take two group elements as input and output an element of another cyclic
group also of order $r$.

Once armed with bilinear maps, we can construct many new cryptosystems
that would not otherwise exist. Possibly the most famous example is a
practical identity-based encryption scheme \cite{bf}.
Researchers were unable to build such a cryptosystem by
conventional means for approximately
twenty years since the problem was posed, though we note that a
scheme based on quadratic residues has been proposed \cite{cocks01}.

Bilinear pairings made their debut in cryptography in the 1990s \cite{mov,fr,fmr},
and were used to break cryptosystems. They were first considered for
constructing cryptosystems years later \cite{sok}.

We shall begin with the original and simplest definition of the pairing.

\section{The Symmetric Pairing}

Let $G, G_T$ be cyclic groups of prime order $r$.
Let $g$ be a generator of $G$.
A \emph{bilinear pairing} or \emph{bilinear map}
$e$ is an efficiently computable function
\[
e:G \times G \rightarrow G_T
\]
such that
\begin{description}
\item [(Nondegeneracy)]
$e(g,g) \ne 1$
\item [(Bilinearity)]
$e(g^a, g^b) = e(g,g)^{a b}$ for all $a, b \in \mathbb{Z}$
\end{description}

We can immediately see the power of such a map: given
$g, g^x, g^y, g^z$, then by bilinearity and nondegeneracy,
$z = x y$ if and only if
$e(g, g^z) = e(g^x, g^y)$. In other words we can solve the Decisional
Diffie-Hellman problem.

However, it is not known how to solve the Computational Diffie-Hellman
or discrete log problem using a pairing.

\section{A Signature Scheme}

Thus we can construct a cyclic group where the Computational Diffie-Hellman
problem is thought to be hard, yet the Decisional variant is easy to solve.
Such groups have been named Gap Diffie-Hellman groups\cite{bls} and
imply a signature scheme:

\begin{description}
\item[Setup]
Choose a Gap Diffie-Hellman group $G$ of prime order $r$.
Publish a generator $g \in G$.

\item[Key Generation]
Choose a random $x$ in $\{1,...,r-1\}$. Output
the public key $g^x$ and the private key $x$.

\item[Signing]
Given a message $h \in G$, output $h^x$.

\item[Verify]
Given a message-signature pair $h, \sigma$ and public key $g^x$,
check that $\langle{ g, h, g^x, \sigma}\rangle$ is a Diffie-Hellman tuple.
\end{description}

It can be shown that this signature scheme is secure against existential
forgery under a chosen-message attack in the random oracle model \cite{bls}.

Hence an abstract view of the pairing is all that is needed to build a
cryptosystem, and frequently this suffices. However,
we shall see that it can be useful to understand pairings in more detail.
For example, we need more facts to show the above signature scheme is
short, which was initially the reason it was proposed.

\section{New Problems}

Classic problems have natural counterparts in pairing-based
cryptography. In the examples below, let $g$ be a generator
for a group $G$ of prime order $r$, and let $e$ be a bilinear map
on $G$.

\begin{description}
\item [Bilinear Diffie-Hellman Problem]
Given $g,g^x,g^y,g^z$ compute $e(g,g)^{xyz}$
\item [Decisional Bilinear Diffie-Hellman Problem]
Given $g,g^x,g^y,g^z,e(g,g)^w$, determine if $w = x y z$.
\item [$q$-Strong Diffie-Hellman Problem]
Given $g,g^x,...,g^{(x^q)}$, compute $c, g^{1/(x_c)}$
for any $c\in\{1,...,r-1\}$.
\end{description}

Various cryptosystems rely on one or more of the above problems to be
hard.

Similarly, sometimes we can see how a conventional cryptosystem
can be converted into a pairing-based cryptosystem.

TODO: ring signature anecdote

\section{Pairings Redefined}

In practice, symmetric pairings can be instantiated by
using suitable supersingular elliptic curves.
However, in order to allow a wider range of curves to be used,
the definition can be modified as follows, sometimes referred
to as the asymmetric pairing.

Let $G_1, G_2, G_T$ be cyclic groups of prime order $r$.
Assume the Diffie-Hellman problem is hard in $G_1$.
Let $\phi : G_2 \rightarrow G_1$ be an efficiently computable group
isomorphism. Let $g_2$ be a generator of $G_2$.
Set $g_1 = \phi(g_2)$ (so $g_1$ generates $G_1$). 
A bilinear pairing $e$ is an efficiently computable function
\[
e:G_1 \times G_2 \rightarrow G_T
\]
such that $e(g_1,g_2) \ne 1$ and
$e(g_1^a, g_2^b) = e(g_1,g_2)^{a b}$ for all $a, b \in \mathbb{Z}$.

Note if a problem is hard $G_1$, it is also hard in $G_2$
due to existence of an efficiently computable
$\phi$.

This definition appears in the literature, but it is advantageous
to modify it further.

\section{The General Bilinear Pairing}

To allow some optimizations on bilinear maps,
we use the following definition.

Let $r$ be a prime.
Let $G_1, G_T$ be cyclic groups of order $r$.
Let $G_2$ be a group where each element except the identity has order $r$.
Again we use multiplicative group notation.
A bilinear pairing $e$ is an efficiently computable function
\[
e:G_1 \times G_2 \rightarrow G_T
\]
such that for all $g_1 \in G_1$ and $g_2 \in G_2$:
\begin{enumerate}
\item
$e(g_1,g_2) = 1$ if and only if $g_1 = 1_{G_1}$ and $g_2 = 1_{G_2}$
(nondegeneracy)
\item
$e(g_1^a, g_2^b) = e(g_1,g_2)^{a b}$ for all $a, b \in \mathbb{Z}$
(bilinearity)
\end{enumerate}

In this setting the hardness assumptions must be altered further.
Depending on the scheme, we may have to assume certain problems are hard in
both $G_1$ and $G_2$, or a combination of the two. For example, we may
need to assume that given $g_1, g_1^x \in G_1$ and $g_2 \in G_2$,
there is no efficient algorithm to compute $g_2^x$. This particular
example is sometimes referred to as
the co-Computational Diffie-Hellman assumption.

\section{Exponentiation as a Bilinear Pairing}

Given some integer $r > 1,$
let us take $G_1 = G_T = \mathbb{Z}_r^*$ and $G_2 = \mathbb{Z}_{r-1}^+$.
Define $e:G_1\times G_2 \rightarrow G_T$ by $e(g, a)= g^a$.

Then it is easily seen that exponentiation in a cyclic group satisfies
the definition of a bilinear
pairing. We may view (pairing-less) cyclic group and RSA cryptosystems
as a pairing where the discrete log problem is easy in $G_2$ and $G_1 = G_T$.

Classic problems can be restated in terms of
pairings. For example:

\begin{description}
\item[Discrete Log Problem]
Given $g \in G_1, c \in G_T$, find $a \in G_2$ such that $e(g,a) = c$.
\item[RSA Problem]
Given $a \in G_2, c \in G_T$, find $g \in G_1$ with
$e(g,a) = c$
\item[Strong RSA Problem]
Given $c \in G_T$, find $g \in G_1, a\in G_2$ with
$e(g,a) = c$
\end{description}

TODO: can build pairing schemes using same assumptions?

\section{Choosing a Definition}

Many cryptosystems designed under the original version of the pairing can
be trivially modified so that they remain secure under the revised
definition, possibly assuming different problems are difficult.
Those that cannot be modified have a limited selection of pairings.

We shall see there are other subtle caveats.
For example, suppose a design goal of a cryptosystem is to minimize the
number of bits needed to represent a group element. If we use
a symmetric pairing, then in typical use, elements will be 512 bits long.
If we forgo symmetry and use two groups $G_1, G_2$ instead,
then it turns out we can have a 160-bit $G_1$ and a 320-bit $G_2$.
