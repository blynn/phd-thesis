\chapter{Bilinear Maps}

Much of modern cryptography depends (and was founded\cite{diffie76new})
on a cyclic group $G = \langle g \rangle$ of prime order $r$ where certain
problems are hard to solve:

\begin{description}
\item [Discrete Log Problem.]
Given $g, g^x$, compute $x$.
\item [Computational Diffie-Hellman Problem.]
Given $g, g^x, g^y$, compute $g^{x y}$.
\item [Decisional Diffie-Hellman Problem.]
Given $g, g^x, g^y, g^z$, determine if $x y = z$.
\end{description}

TODO: formal defn of hard

A vast array of cryptosystems can be built thanks to these groups. 
But what if we could somehow augment these groups and increase their
capabilities?

Bilinear maps, or pairings, are functions with special
properties that exist for some of these groups.
They take two group elements as input and output an element of another cyclic
group also of order $r$.

Once armed with bilinear maps, we can construct many new cryptosystems
that would not otherwise exist. Possibly the most famous example is a
practical identity-based encryption scheme \cite{bf}.
Researchers were unable to build such a cryptosystem by
conventional means for approximately
twenty years since the problem was posed, though we note that a
scheme based on quadratic residues has been proposed \cite{cocks01}.

Bilinear pairings made their debut in cryptography in the 1990s \cite{mov,fr,fmr},
and were used to break cryptosystems. They were first considered for
constructing cryptosystems years later \cite{sok}.

We shall begin with the original and simplest definition of the pairing.

\section{The Symmetric Pairing}

Let $G, G_T$ be cyclic groups of prime order $r$.
Let $g$ be a generator of $G$.
A \emph{bilinear pairing} or \emph{bilinear map}
$e$ is an efficiently computable function
\[
e:G \times G \rightarrow G_T
\]
such that
\begin{enumerate}
\item
\emph{(Nondegeneracy)}
$e(g,g) \ne 1$
\item
\emph{(Bilinearity)}
$e(g^a, g^b) = e(g,g)^{a b}$ for all $a, b \in \mathbb{Z}$
\end{enumerate}

We can immediately see the power of such a map: given
$g, g^x, g^y, g^z$, then by bilinearity and nondegeneracy,
$z = x y$ if and only if
$e(g, g^z) = e(g^x, g^y)$. In other words we can solve the Decisional
Diffie-Hellman problem.

However, it is not known how to solve the Computational Diffie-Hellman
or discrete log problem using a pairing.

\section{A Signature Scheme}

Thus we can construct a cyclic group where the Computational Diffie-Hellman
problem is thought to be hard, yet the Decisional variant is easy to solve.
Such groups have been named Gap Diffie-Hellman groups\cite{bls} and
imply a signature scheme:

\begin{description}
\item[Setup.]
Choose a Gap Diffie-Hellman group $G$ of prime order $r$.
Publish a generator $g \in G$.

\item[Key Generation.]
Choose a random $x$ in $\{1,...,r-1\}$. Output
the public key $g^x$ and the private key $x$.

\item[Signing.]
Given a message $h \in G$, output $h^x$.

\item[Verify.]
Given a message-signature pair $h, \sigma$ and public key $g^x$,
check that $\langle{ g, h, g^x, \sigma}\rangle$ is a Diffie-Hellman tuple.
\end{description}

It can be shown that this signature scheme is secure against existential
forgery under a chosen-message attack in the random oracle model \cite{bls}.

Hence an abstract view of the pairing is all that is needed to build a
cryptosystem, and frequently this suffices. However,
we shall see that it can be useful to understand pairings in more detail.
For example, we need more facts to show the above signature scheme is
short, which was initially the reason it was proposed.

\section{New Hardness Assumptions}

Classic problems have natural counterparts in pairing-based
cryptography. In the examples below, let $g$ be a generator
for a group $G$ of prime order $r$, and let $e$ be a bilinear map
on $G$.

\begin{description}
\item [Bilinear Diffie-Hellman Problem.]
Given $g,g^x,g^y,g^z$ compute $e(g,g)^{xyz}$
\item [Decisional Bilinear Diffie-Hellman Problem.]
Given $g,g^x,g^y,g^z,e(g,g)^w$, determine if $w = x y z$.
\item [$q$-Strong Diffie-Hellman Problem.]
Given $g,g^x,...,g^{(x^q)}$, compute $c, g^{1/(x_c)}$
for any $c\in\{1,...,r-1\}$.
\end{description}

TODO: Reductions between them

Various cryptosystems rely on one or more of the above problems to be
hard.

Similarly, sometimes it is easy to convert a conventional cryptosystem
into a pairing-based cryptosystem. For example,
the above pairing-based signature scheme and a ring signature scheme
due to Rivest et al. \cite{rst} were presented in adjacent sessions
at a conference. Someone who attended both talks would not have much
difficulty in synthesizing the two ideas together. Indeed,
a pairing-based ring signature scheme was presented about one
year later\cite{bls2}.

\section{Pairings Redefined}

In practice, symmetric pairings can be instantiated by
using suitable supersingular elliptic curves.
However, in order to allow a wider range of curves to be used,
the definition can be modified as follows, sometimes referred
to as the asymmetric pairing.

Let $G_1, G_2, G_T$ be cyclic groups of prime order $r$.
Assume the Diffie-Hellman problem is hard in $G_1$.
Let $\phi : G_2 \rightarrow G_1$ be an efficiently computable group
isomorphism. Let $g_2$ be a generator of $G_2$.
Set $g_1 = \phi(g_2)$ (so $g_1$ generates $G_1$). 
A bilinear pairing $e$ is an efficiently computable function
\[
e:G_1 \times G_2 \rightarrow G_T
\]
such that $e(g_1,g_2) \ne 1$ and
$e(g_1^a, g_2^b) = e(g_1,g_2)^{a b}$ for all $a, b \in \mathbb{Z}$.

Note if a problem is hard $G_1$, it is also hard in $G_2$
due to existence of an efficiently computable
$\phi$.

This definition appears in the literature, but it is advantageous
to modify it further.

\section{The General Bilinear Pairing}

To allow some optimizations on bilinear maps,
we use the following definition.

Let $r$ be a prime.
Let $G_1, G_T$ be cyclic groups of order $r$.
Let $G_2$ be a group where each element except the identity has order $r$.
Again we use multiplicative group notation.
A bilinear pairing $e$ is an efficiently computable function
\[
e:G_1 \times G_2 \rightarrow G_T
\]
such that
\begin{enumerate}
\item
\emph{(Nondegeneracy)}
$e(g_1,g_2) = 1_{G_T}$ for all $g_2 \in G_2$ if and only if $g_1 = 1_{G_1}$,
and similarly 
$e(g_1,g_2) = 1_{G_T}$ for all $g_1 \in G_1$ if and only if $g_2 = 1_{G_2}$.
\item
\emph{(Bilinearity)}
for all $g_1 \in G_1$ and $g_2 \in G_2$:
$e(g_1^a, g_2^b) = e(g_1,g_2)^{a b}$ for all $a, b \in \mathbb{Z}$
\end{enumerate}

In this setting the hardness assumptions must be altered further.
Depending on the scheme, we may have to assume certain problems are hard in
both $G_1$ and $G_2$, or a combination of the two. For example, we may
need to assume that given $g_1, g_1^x \in G_1$ and $g_2 \in G_2$,
there is no efficient algorithm to compute $g_2^x$. This particular
example is sometimes referred to as
the co-Computational Diffie-Hellman assumption.

We have not required $r$ to be prime. A composite group
order is useful for some cryptosystems\cite{bgn},
but we must be aware that in this case even if $g_1$ and $g_2$ have order
$r$, $e(g_1, g_2)$ may not be a generator of $G_T$, but rather a generator
of some subgroup of $G_T$ whose order is a factor of $r$.

\section{Exponentiation as a Bilinear Pairing}

Given some integer $r > 1,$
let us take $G_1 = G_T = \mathbb{Z}_r^*$ and $G_2 = \mathbb{Z}_{r-1}^+$.
Define $e:G_1\times G_2 \rightarrow G_T$ by $e(g, a)= g^a$.

Then it is easily seen that exponentiation in a cyclic group satisfies
the definition of a bilinear
pairing. Thus we may view all discrete log and RSA cryptosystems
as pairing-based cryptosystems, though there are significant differences
in this setting. For example, the discrete log problem is easy
in $G_2$ and $G_1 = G_T$.

Classic problems can be restated in terms of
pairings. For example:

\begin{description}
\item[Discrete Log Problem.]
Given $g \in G_1, c \in G_T$, find $a \in G_2$ such that $e(g,a) = c$.
\item[RSA Problem.]
Given $a \in G_2, c \in G_T$, find $g \in G_1$ with
$e(g,a) = c$
\item[Strong RSA Problem.]
Given $c \in G_T$, find $g \in G_1, a\in G_2$ with
$e(g,a) = c$
\end{description}

TODO: can build pairing schemes using same assumptions?

\section{Choosing a Definition}

Many cryptosystems designed under the original version of the pairing can
be trivially modified so that they remain secure under the revised
definition, possibly assuming different problems are difficult.
Those that cannot be modified have a limited selection of pairings.

We shall see there are other subtle caveats.
For example, suppose a design goal of a cryptosystem is to minimize the
number of bits needed to represent a group element. If we use
a symmetric pairing, then in typical use, elements will be 512 bits long.
If we forgo symmetry and use two groups $G_1, G_2$,
then it turns out we can find a 160-bit $G_1$ and a 320-bit $G_2$.
